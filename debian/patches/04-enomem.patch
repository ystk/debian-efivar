commit 86e17a239a3d16aa1520b6c06146857f48def8f0
Author: Peter Jones <pjones@redhat.com>
Date:   Mon Nov 3 10:40:10 2014 -0500

    Return ENOMEM if we're going to overrun the buffer in read_file.
    
    I don't actually think this case will ever happen in efivar, since the
    paths we're reading from are generated internally and always point at
    sysfs or proc and /cannot/ be that large, but it's still the right thing
    to do.
    
    Based on the bug and patch reported in this thread:
    https://bugs.debian.org/cgi-bin/bugreport.cgi?bug=764386
    
    Signed-off-by: Peter Jones <pjones@redhat.com>

diff --git a/src/util.h b/src/util.h
index fdeb649..a12cdd7 100644
--- a/src/util.h
+++ b/src/util.h
@@ -57,6 +57,15 @@ read_file(int fd, uint8_t **buf, size_t *bufsize)
 		if (s == 0) {
 			break;
 		} else if (s == 4096) {
+			/* See if we're going to overrun and return an error
+			 * instead. */
+			if (size > (size_t)-1 - 4096) {
+				free(*buf);
+				*buf = NULL;
+				*bufsize = 0;
+				errno = ENOMEM;
+				return -1;
+			}
 			newbuf = realloc(*buf, size + 4096);
 			if (newbuf == NULL) {
 				int saved_errno = errno;
